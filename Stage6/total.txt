typedef struct symbol 
{
	char *name; //name of symbol
	short type; //VAR, BUILT IN,CNST and UNDEF (seen but not defined yet)
	
	union
	{
		double val; //if its a variable
		double (*ptr)(); //if its a builtin, u.ptr is a pointer to a function that returns double
		int (*defn)();
		char *str; //string
		double *arrptr;
	} u;
	struct symbol *next; //a linked list (for the symbol table)
} symbol;

symbol *install(char *s, int t, double d), *lookup(char *s); //we are making two functions here
			      //install- returns the pointer to the node symbol
			      //lookup- returns the pointer to the node with the matching name

typedef union Datum
{
	double val;
	symbol *sym;
} Datum; //interpreter stack type

extern Datum pop();

typedef int (*Inst)();
#define STOP (Inst)0 //STOP- value- NULL; type- pointer to a function that returns int
#define contcode (Inst)8
#define breakcode (Inst)4

extern Inst *prog, *progp, *code(Inst f), *progbase;
extern int eval(), add(), sub(), mul(), div_(), negate(), power(), mod(), sys(), prevset(), define(symbol* sp), call();
extern int assign(), bltin(), varpush(), constpush(), print(), funcret(), procret(), ret(), arg(), argassign();
extern int varread(), arrpop(), arrpush(), arrinit(), arrassign();
extern int prexpr(), prstr(), arrlen(), cnflush(), parassgn();
extern int gt(), ge(), lt(), le(), eq(), ne(), and_(), or_(), not_(), inc(), dec();
extern int ifcode(), whilecode(), forcode();
%{

//all standard libraries are included here
#include <ctype.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <setjmp.h>
#include "hoc.h" // for lookup and install

#define code2(c1,c2) code(c1) ; code(c2)
#define code3(c1,c2,c3) code(c1) ; code(c2) ; code(c3)

extern double Pow(double a, double b); //belongs to math.c, Pow is invoked when '^' is encountered
extern void init(); //belongs to init.c, this initilaizes the constants and the builtins
extern int initcode();
extern int execute(Inst *p);
extern void *emalloc();

int yylex(void); //for lexing, sending values through yylval and returning its token type
int lineno = 1; 
char *progname;

jmp_buf begin; //we define a jum_buf struct- begin which would hold the timestamps and the necesary details with we setjmp

//some error catching functions
void fpecatch(); //for floating point errors
void execerror(const char *s, const char *t); //resets the state and gives warning the parameters
void warning (const char *s, const char *t); //prints on stderr
void yyerror(char *s); //called upon by yylex for misc errors

static int indef = 0;

void defnonly(char *s)
{
	if (indef == 0) execerror(s, "out of definition");
}

FILE *fin;

%}

%union
{
	Inst *inst; //machine instruction
	symbol *sym; //symbol table pointer type
	int narg; //number of arguments			
}

%token <sym> NUMBER VAR BLTIN UNDEF CNST BLTIN2 BLTIN0 SYS WHILE IF ELSE PRINT BREAK CONTINUE FOR STRING ARRLEN 
%token <sym> FUNCTION PROCEDURE RETURN FUNC PROC READ ARR ARRAY
%token <narg> ARG
%type  <inst> stmt asgn expr stmtlist prlist 
%type  <inst> cond while if end newl break continue for fexpr begin array defn
%type  <sym>	procname
%type  <narg> arglist paramlist

%right '='
%left OR
%left AND
%left GT GE LT LE EQ NE INC DEC
%left '+' '-'
%left '*' '/' '%'
%left  UNARYMINUS NOT
%right '^' //2 ^ 2 ^ 3 is 2^8 not 4^3 therefore its is right associtative


%%
list:	
    	|list '\n'		
			|list defn '\n'
			|list asgn '\n'									{code3(prevset, (Inst)pop, STOP); return 1; }
			|list error '\n' 								{yyerrok; } //a flag to reassure that the error has been taken care of
			|list expr '\n' 								{code3(prevset, print, STOP); return 1; }
			|list stmt '\n'									{code(STOP); return 1; }

asgn:	 VAR '=' expr 									{$$ = $3; code3(varpush, (Inst)$1, assign); }
			|ARRAY '[' expr ']' '=' expr    {$$ = $6; code2(arrpush, (Inst)$1); }
			|CNST '=' expr									{execerror("constant cant be changed",$1->name); }
			|ARG '=' expr										{defnonly("$"); code2(argassign, (Inst)$1); $$ = $3; }

stmt: 	 expr 																		{code((Inst)pop); }
				|array
				|RETURN 																	{defnonly("return"); code(procret); }
				|RETURN expr															{defnonly("return"); $$ = $2; code(funcret); }
				|PROCEDURE begin '(' arglist ')'					{$$ = $2; code3(call, (Inst)$1, (Inst)$4); }
				|PRINT prlist 														{$$ = $2; }
				|break
				|continue
				|PRINT expr 																					{ code(prexpr); $$ = $2; }
				|for '(' fexpr ';' fexpr ';' fexpr ')' newl stmt end 	{	($1)[1] = (Inst)$3; 
																															($1)[2] = (Inst)$5;
																															($1)[3] = (Inst)$7; 
																															($1)[4] = (Inst)$10;
																															($1)[5] = (Inst)$11; }

				|while cond newl stmt end 											{($1)[1] = (Inst)$4; ($1)[2] = (Inst)$5; }
				|if cond newl stmt end													{($1)[1] = (Inst)$4; ($1)[3] = (Inst)$5; }
				|if cond newl stmt end ELSE newl stmt end 			{($1)[1] = (Inst)$4; ($1)[2] = (Inst)$8; ($1)[3] = (Inst)$9; }
				|'{' stmtlist '}'																{$$ = $2; }


cond:		'(' expr ')' 									{code(STOP); $$ = $2; }

while:	WHILE													{$$ = code3(whilecode, STOP, STOP); }


for: 		FOR 													{$$ = code3(forcode, STOP, STOP); code3(STOP,STOP,STOP);}

if:			IF 														{$$ = code(ifcode); code3(STOP,STOP,STOP); }

end:																	{code(STOP); $$ = progp; }

stmtlist:															{$$ = progp; }
				|stmtlist newl
				|stmtlist stmt newl

fexpr:	expr 												{code(STOP); $$ = $1; }

expr: 	 NUMBER												{$$ = code2(constpush, (Inst)$1); }
    		|VAR													{$$ = code3(varpush, (Inst)$1, eval); } 
				|ARG 													{defnonly("$"); $$ = code2(arg, (Inst)$1); }
				|VAR INC											{$$ = code3(varpush, (Inst)$1, inc); }
				|VAR DEC											{$$ = code3(varpush, (Inst)$1, dec); }
				|CNST													{$$ = code2(constpush, (Inst)$1); }
				|asgn                         
				|FUNCTION begin '(' arglist ')' {$$ = $2; code3(call, (Inst)$1, (Inst)$4); }
				|ARRAY '[' expr ']'						{$$ = code2(arrpop, (Inst)$1); }
				|BLTIN '(' expr ')' 					{$$ = $3; code2(bltin, (Inst)$1); }
				|BLTIN2 '(' expr ',' expr ')'	{$$ = $5; code2(bltin, (Inst)$1); }
				|READ '('')'									{$$ = code(varread); }
				|BLTIN0 '(' ')'								{code2(bltin, (Inst)$1); }
				|expr '+' expr 	    					{code(add); }
				|expr '-' expr  	    				{code(sub); }
				|expr '*' expr	      				{code(mul); }
				|expr '/' expr								{code(div_); }
				|expr '%' expr								{code(mod); }
				|expr '^' expr     						{code(power); }
				|'(' expr ')'    							{$$ = $2; }	
				| '-' expr  %prec UNARYMINUS	{$$ = $2; code(negate); }
				|expr GT expr 								{code(gt); }
				|expr GE expr									{code(ge); }
				|expr LT expr									{code(lt); }
				|expr LE expr									{code(le); }
				|expr EQ expr									{code(eq); }
				|expr NE expr 								{code(ne); }
				|expr AND expr								{code(and_); }
				|expr OR expr 								{code(or_); }
				|NOT expr 										{$$ = $2; code(not_); }
				|ARRLEN '(' ARRAY ')'					{$$ = code2(arrlen, (Inst)$3); }

begin:																{$$ = progp; }

prlist:	expr													{code(prexpr); }
			 |STRING 												{$$ = code2(prstr, (Inst)$1); }
			 |prlist ',' expr 							{code(prexpr); }
			 |prlist ',' STRING							{$$ = code2(prstr, (Inst)$3); }

defn: 	FUNC procname  {$2->type = FUNCTION; indef = 1;  }  '(' paramlist ')' {code2(cnflush,(Inst)$5); } newl stmt {code(procret); define($2); indef = 0; }
			 |PROC procname  {$2->type = PROCEDURE; indef = 1; }  '(' paramlist ')' {code2(cnflush,(Inst)$5); } newl stmt {code(procret); define($2); indef = 0; }

array:  ARR VAR '[' expr  ']' 										         {$2->type = ARRAY; $$ = code2(arrinit, (Inst)$2); }
		 	 |ARR VAR '[' ']' '=' 	'[' arglist ']'  						 {$2->type = ARRAY; $$ = code3(arrassign, (Inst)$2, (Inst)$7); }

procname:	VAR
				 |FUNCTION
				 |PROCEDURE
				 |ARRAY

arglist: 															{$$ = 0; }
			 	 |expr 												{$$ = 1; }
				 |arglist ',' expr 						{$$ = $1 + 1; }

paramlist:														{$$ = 0; }
				 |VAR 												{$$ = 1; code2(parassgn, (Inst)$1); }
				 |VAR ',' paramlist 					{$$ = $3 + 1; code2(parassgn, (Inst)$1); }

break:	BREAK													{$$ = code(breakcode); }

continue: CONTINUE										{$$ = code(contcode); }

newl: 
			 |'\n'
			 |newl '\n'
%%

int follow(int expect, int ifyes, int ifno)
{
	int c = getc(fin);
	if (c == expect) return ifyes;
	ungetc(c,fin);
	return ifno;
}

int backslash(int c)
{
	if (c != '\\') return c;
	c = getc(fin);

	switch (c)
	{
		case 'n': return '\n';
		case 'b': return '\b';
		case 'r': return '\r';
		case 't': return '\t';
		case 'f': return '\f';
		default:  return c;
	}
}

int yylex(void)
{
	int c; 
	while ((c = getc(fin)) == ' ' || c == '\t') ; //get rid of blanks
	if (isdigit(c) || c == '.') 
	{
		double d;
		ungetc(c,fin);
		fscanf(fin,"%lf",&d);
		yylval.sym = install("", NUMBER, d); //we are adding the number to the symbol table, we dont assign a name to it.
		return NUMBER;
	} 
	else if (isalpha(c))
	{
		symbol *s;
		char sbuf[100]; 
		char *p = sbuf;
		do
		{
			*p++ = c;
		} while ((c = getc(fin)) != EOF && (isalnum(c) || c == '_'));
		if (strcmp("sys",sbuf) == 0)
		{
			if (c == '-')
			{
				char buf[100];
				int i = 0,c;
				while((c = getc(fin)) != '\n')
				{
					buf[i++] = c;
				}
				buf[i] = '\0';
				ungetc(c,fin);
				symbol *s = install(buf, SYS, 0.0);
				yylval.sym = s;
				return SYS;
			}
			else execerror("sys is a builtin command","");
		}
		ungetc(c, fin);
		*p = '\0';
		if ((s = lookup(sbuf)) == 0) s =  install(sbuf, UNDEF, 0.0); //if sbuf is not present in the table, then we add it and set it to undef
		yylval.sym = s; 
		return s->type == UNDEF ? VAR : s->type; //if the type is undef, return VAR else return s->type (builtin or var)
	}
	else if (c == '_')
	{
		yylval.sym = lookup("_");
		return VAR;
	}
	else if (c == '/')
	{
		int checkcom = follow('/', 1, 0);
		if (checkcom)
		{
			while ((c = getc(fin)) != '\n' && c != EOF);
		}
	}
	else if (c == '$')
	{
		int n = 0,c;
		while (isdigit(c = getc(fin)))
		{
			n = n*10 + (c - '0');
		}
		ungetc(c,fin);
		if (n == 0) execerror("starange $","");
		yylval.narg = n;
		return ARG;
	}
	else if (c == '"')
	{
		char sbuf[100];
		int p;
		for (p = 0; (c = getc(fin)) != '"'; p++)
		{
			if (c == '\n' || c == EOF) execerror("missing quote","");
			if (p >= 100) execerror("size of string too long","");
			sbuf[p] = backslash(c); //checks for newline characters
		}
		sbuf[p] = '\0';
		yylval.sym = (symbol *)emalloc(strlen(sbuf) + 1); 
		strcpy(yylval.sym, sbuf); //rubbish if you ask me
		return STRING;
	}
	switch(c)
	{
	case '>': return follow('=',GE,GT);
	case '<': return follow('=',LE,LT);
	case '=': return follow('=',EQ,'=');
	case '!': return follow('=',NE,NOT);
	case '|': return follow('|',OR,'|');
	case '&': return follow('&',AND,'&');
	case '+': return follow ('+',INC,'+'); 
	case '-':  return follow ('-',DEC,'-'); 
	case '\n': lineno++; return '\n';
	default: return c;
	}
} 

void fpecatch()
{
	execerror("floating point error","");
}

void yyerror(char *s)
{
	execerror(s, "");
}

void warning(const char *s, const char *t)
{
	fprintf(stderr,"\033[0;31m line no:- %d|%s %s \033[0m\n",lineno, (strcmp(t,"") == 0) ? "":t, s);
}

void execerror(const char *s, const char *t)
{
	warning (s,t);
	longjmp(begin, 0);	
}

int main(int argc, char **argv)
{
		
	progname = argv[0];	
	if (argc == 2)
	{
		fin = fopen(argv[1],"r");
		if (!fin)
		{
			printf("%s- file not found",argv[1]);
			return 0;
		}
	}
	else fin = stdin;

	init();
	setjmp(begin);
	signal(SIGFPE, fpecatch);
	for (initcode(); yyparse(); initcode()) execute(progbase); //yyparse() will return 0 at the end of file
	if (fin != stdin) fclose(fin);
	return 0;
}
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "hoc.h"
#include "hoc.tab.h"

static symbol *root = NULL;
extern void execerror(char *s, char *t);

void *emalloc(int size)
{
	void *allocheck = malloc(size);
	if (allocheck == NULL) execerror("memory limit exceeded", "");
	return allocheck;
}

symbol *install(char *s, int t, double val)
{
	symbol *sp;
	sp = emalloc(sizeof(symbol));
	sp->name = emalloc(strlen(s) + 1);
	strcpy(sp->name, s);
	sp->type = t;
	sp->u.val = val;
	sp->next = root;
	root = sp;
	return sp;
}

symbol *lookup(char *s)
{
	symbol *i;
	for(i = root; i != NULL; i = i->next)
	{
		if(strcmp(i->name,s) == 0) return i;
	}
	return NULL;
}


//contains routines that execute  machine instructions and manipulate the stack

#include "hoc.h"
#include "hoc.tab.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <string.h>

#define B 4
#define C 8

extern void execerror(const char *s, const char *t);
extern Datum dispatch (Datum p1, Datum p2, symbol *s);
extern void echeck(double val);


static Datum *stack;
Inst *prog;
static Datum *stackp; //returns the pointer to the next free spot on the stack
static int sizes = 1000;

#define NPROG 2000

Inst *pc; //program counter, after all the programs are loaded in the prog array and its time to execute
Inst *progp; //keeps track of the instructions in the prog (while the instructions are being read)
static int sizep = 2000;
Inst *progbase; //start of current subprogram
int returning = 0; //1 if return statement is seen

typedef struct Frame 
{
	symbol *sp;  //keeps in track of all the symbol table entries in a function
	Inst *retpc; //where to return the program after the return statement is seen
	Datum *argn; //nth argument on the stack
	int nargs; //number of argument
	symbol *local;
	int currstatus;
} Frame;

Frame *frame; //recursive/fucntion calls within functions 
Frame *fp;
static int nframe = 100;

void makebufs()
{
	
	prog = (Inst *)malloc(sizeof(Inst)*2000); //array containing a set of programs
	stack = (Datum *)malloc(sizeof(Datum)*1000); //stack on which th operations are being performed
	frame = (Frame *)malloc(sizeof(Frame)*100); //create the frame stacki
	progbase = prog;
}

void initcode()
{
	progp = progbase; //probably to keep building on the stack after the function is defined, instead of flushing it out
	stackp = stack;
	fp = frame; //every function keeps one frame to store relevent information
	returning = 0;
}

int define(symbol *sp) //right now the function name is stored as a var type
{
	sp->u.defn = (Inst)progbase; //the beginning of the program 
	progbase = progp; 					 //progp right now is at the end of the program, therefore we set progbase to progp so that the function is
	return 2;										//remembered
}

//main calls to manipulate the stack

void push(Datum d) //pushes d into the stack
{
	if (stackp >= &stack[sizes])
	{
		sizes += 1000;
		void *check = realloc(stack, sizeof(Datum)*sizes);
		if (check == NULL) execerror("no space available in stack","");
		else stack = (Datum *)check;
	}
	*(stackp++) = d;
}

Datum pop() //pops the top element from the stack
{
	if (stackp <= stack) execerror("nothing left to pop","");
	return *(--stackp);
}

//prog-> array of pointers to a functionr returning int

Inst *code(Inst f) //code returns a pointer to Inst, Inst-> pointer to a function returning int
{
	Inst *oprogp = progp;
	if (progp >= &prog[sizep])
	{
		sizep += 2000;
		void *check = realloc(prog, sizeof(Inst)*sizep);
		if (check == NULL) execerror("no space available for storing programs","");
		else prog = (Inst *)check;
	}
	*(progp++) = f;
	return oprogp; //where the current program is stored, not the pointer to the next free space
}

int execute(Inst *p) //p has the address of the cell with the instruction
{
	for (pc = p; *pc != STOP && !returning; ) 
	{
				if (*pc == breakcode) return B;
				else if (*pc == contcode)  return C;
				int check = (*(*pc++))();
				if (check == B) return B;
				else if (check == C) return C;
	}
	return 2;
}

int constpush()
{
	Datum d;
	d.val = ((symbol *)*pc++)->u.val;
	push(d);
	return 2;
}

int varpush() {
    Datum d;
    symbol *sp = (symbol *)(*pc++);
    d.sym = sp; // Default to global

    // If fp > frame, we are inside a function call
    if (fp > frame && fp->nargs > 0) {
        for (int i = 0; i < fp->currstatus; i++) {
            if (fp->local[i].name && strcmp(fp->local[i].name, sp->name) == 0) {
                d.sym = &(fp->local)[i];
                break;
            }
        }
    }
    if (*pc != assign && d.sym->type == UNDEF) execerror("is not defined", d.sym->name);
    push(d);
    return 2;
}

int add()
{
	Datum d1, d2;
	d2 = pop();
	d1 = pop();
	d1.val += d2.val;
	push(d1);
	return 2;
}

int sub()
{
	Datum d1, d2;
	d2 = pop();
	d1 = pop();
	d1.val -= d2.val;
	push(d1);
	return 1;
}

int mul()
{
	Datum d1, d2;
	d2 = pop();
	d1 = pop();
	d1.val *= d2.val;
	push(d1);
	return 2;
}

int div_()
{
	Datum d1, d2;
	d2 = pop();
	d1 = pop();
	if (d2.val == 0) execerror("cant divide by 0","");
	d1.val /= d2.val;
	push(d1);
	return 2;
}

int mod()
{
	Datum d1, d2;
	d2 = pop();
	d1 = pop();
	if (d2.val == 0) execerror("cant divide by 0","");
	int mod_val = (int)(d1.val) % (int)(d2.val);
	d1.val = (float)mod_val;
	push(d1);
	return 2;
}

int power()
{
	Datum d1, d2;
	d2 = pop();
	d1 = pop();
	d1.val = pow(d1.val, d2.val);
	push(d1);
	return 2;
}

int negate()
{
	Datum d1 = pop();
	d1.val = -d1.val;
	push(d1);
	return 2;
}

int sys()
{
	Datum d1 = pop();
	system(d1.sym->name);
	return 2;
}

int eval()
{
	Datum d;
	d = pop();
	if (d.sym->type == UNDEF) execerror("undefined variable",d.sym->name);
	d.val = d.sym->u.val;
	push(d);
	return 2;
}

int assign() //assign top value to the next value
{
	Datum d1, d2; 
	d1 = pop();
	d2 = pop();
	if (d1.sym->type != VAR && d1.sym->type != UNDEF) execerror("assignment to a non variable",d1.sym->name);
	d1.sym->u.val = d2.val;
	d1.sym->type = VAR;
	push (d2);
	return 2;
}

int print()
{
	Datum d;
	d = pop();
	printf("\t%0.6lf\n",d.val);
	return 2;
}

int bltin()
{
	symbol *s = (symbol *)*pc++;
	int type = s->type;
	Datum p1, p2;
	if (type == BLTIN) p1 = pop();
	else if (type == BLTIN2) {p2 = pop(); p1 = pop();}
	push (dispatch(p1, p2, s));
	return 2;
}

int prevset()
{
	symbol *s = lookup("_");
	Datum d1 = pop();
	s->u.val = d1.val;
	push(d1);
	return 2;
}

int whilecode()
{
	Datum d;
	Inst *savepc = pc; 
	while (1)
	{
		
		execute(savepc+2);
		d = pop(); //we evaluate the condtion here;
		if (d.val == 0) break;

		int check = execute(*((Inst **)(savepc))); // run the body
		if (check == B) break;
		else if (check == C) continue;
	}
	if (!returning ) pc = *((Inst **)(savepc+1));//next statement
	return 2;
}

int forcode()
{
	Inst *savepc = pc;
	execute(*((Inst **)(savepc)));
	Datum d;
	while (1)
	{
		execute(*((Inst **)(savepc+1)));
		d = pop(); //we evaluate the condtion here;
		if (d.val == 0) break;

		int check = execute(*((Inst **)(savepc+3))); // run the body
		if (check == B) break;
		execute(*((Inst **)(savepc+2)));
		if (check == C) continue;
	}
	if ( !returning  ) pc = *((Inst **)(savepc+4));//next statement
	return 2;
}

int ifcode()
{
	Datum d;
	Inst *savepc = pc;

	execute(savepc+3);
	d = pop();
	if (d.val) 
	{
		int check = execute(*((Inst **)(savepc))); 
		if (check == B) return B;
		else if (check == C) return C;
	}
	else if (*((Inst **)(savepc+1))) 
	{
		int check = execute(*((Inst **)(savepc+1)));
		if (check == B) return B;
		else if (check == C) return C;
	}
	if( !returning ) pc = *((Inst **)(savepc+2));
	return 2;
}

int isinteger(double x) 
{
    if (!isfinite(x)) return 0;
    return fabs(x - nearbyint(x)) <= DBL_EPSILON * fabs(x);
}

int prexpr()
{
	Datum d = pop();
	if (isinteger(d.val)) printf("%d",(int)d.val);
	else printf("%.6lf", d.val);
	return 2;
}

//now for the trivial operators

int ge()
{
	Datum d2 = pop();
	Datum d1 = pop();
	d1.val = (double)(d1.val >= d2.val);
	push(d1);
	return 2;
}

int gt()
{
	Datum d2 = pop();
	Datum d1 = pop();
	d1.val = (double)(d1.val > d2.val);
	push(d1);
	return 2;
}

int le()
{
	Datum d2 = pop();
	Datum d1 = pop();
	d1.val = (double)(d1.val <= d2.val);
	push(d1);
	return 2;
}

int lt()
{
	Datum d2 = pop();
	Datum d1 = pop();
	d1.val = (double)(d1.val < d2.val);
	push(d1);
	return 2;
}

int eq()
{
	Datum d2 = pop();
	Datum d1 = pop();
	d1.val = (double)(d1.val == d2.val);
	push(d1);
	return 2;
}

int ne()
{
	Datum d2 = pop();
	Datum d1 = pop();
	d1.val = (double)(d1.val != d2.val);
	push(d1);
	return 2;
}

int and_()
{
	Datum d2 = pop();
	Datum d1 = pop();
	d1.val = (double)(d1.val && d2.val);
	push(d1);
	return 2;
}

int or_()
{
	Datum d2 = pop();
	Datum d1 = pop();
	d1.val = (double)(d1.val || d2.val);
	push(d1);
	return 2;
}

int not_()
{
	Datum d = pop();
	d.val = !(d.val);
	push(d);
	return 2;
}

int inc()
{
	Datum d; 
	d = pop();
	if (d.sym->type != VAR) execerror("variable is undefined",d.sym->name);
	d.sym->u.val = d.sym->u.val + 1;
	push (d);
	return 2;
}

int dec()
{
	Datum d; 
	d = pop();
	if (d.sym->type != VAR) execerror("variable is undefined",d.sym->name);
	d.sym->u.val = d.sym->u.val - 1;
	push (d);
	return 2;
}


//how the program memory looks like-
//   |  CALL  |  ->  |  (Inst)FUNCTION  /  ->  /  (Inst)ARGLIST  / 
//   										^^^^^^^^^^^^^^
//   													PC

int call() {
    symbol *s = (symbol *)pc[0];
    if (fp++ >= &frame[nframe - 1])
		{
			nframe += 100;
			Frame *check = (Frame *)realloc(frame, nframe);
			if (check == NULL) execerror("buffer overflow","");
			frame = check;
		}
    fp->sp = s;
    fp->nargs = (int)pc[1];
    fp->retpc = pc + 2;
    fp->argn = stackp - 1; 
    fp->local = (symbol *)calloc(fp->nargs, sizeof(symbol)); // Use calloc to zero memory
    fp->currstatus = 0;

    execute(s->u.defn);   
    returning = 0;
    return 2;
}

int ret() {
    // Clean up THIS frame's local memory before leaving
    for (int i = 0; i < fp->currstatus; i++) {
        if (fp->local[i].name) free(fp->local[i].name);
    }
    free(fp->local);

    // No need to pop arguments here if parassgn already pop()'d them
    pc = (Inst *)fp->retpc;
    --fp;
    returning = 1;
    return 2;
}

int funcret()
{
	Datum d;
	if (fp->sp->type == PROCEDURE) execerror(fp->sp->name,"(void) returns value");
	d = pop();
	ret();
	push(d);
	return 2;
}

int procret()
{
	if(fp->sp->type == FUNCTION) execerror(fp->sp->name,"(func) returns no value");
	ret();
	return 2;
}

/*							| 10 | 20 | 30 
														^^					
														fp->argn
								
								$2 -> nargs = 2;
								argn[2-3].val = 20;
								therore 
								getarg = | 20 |
*/

double *getarg()
{
	int nargs = (int)*pc++;
	if (nargs > fp->nargs) execerror(fp->sp->name, "not enough arguments");
	return &fp->argn[nargs - fp->nargs].val; 
}


//how the program memory looks like
//																/  ARG  / -> /  Inst_2 (for example)  / -> /  next bytecode  /
//																							^^^^^^^^^^^^^^^^^^^^^^^^
//																												PC
																											
int arg() //pushes the argument into the stack
{
	Datum d;
	d.val = *getarg();
	push(d);
	return 2;
}

/*
 																/ 	ARGASSIGN 	/ -> /  INST_2  / -> /  next bytecode  /
																											^^^^^^^^^
																													PC

*/

int argassign()
{
	Datum d;
	d = pop(); //we get the value evaluated from the expr here
	push(d);
	*getarg() = d.val; //-> we change the value of $2 to d
	return 2;
}

int prstr()
{
	printf("%s",(char *)*pc++);
	return 2;
}

/*
 										input- read(x)
										read -> BLTIN for varread
										tokens -
										BLTIN -> expr
										how its added to the program memory- 
										/  varread  / -> /  (Inst)expr  / -> /  next bytecode  /
																				^^^^^^^^^^
																						PC
*/
int varread()
{
    Datum d;
    double cval;
    if (fscanf(stdin, "%lf", &cval) != 1) {
        getc(stdin); 
        execerror("non number to read into", "");
    } else {
			d.val = cval;
			push(d);
    }
    return 2;
}

int arrinit()
{
	symbol *sp = (symbol *)*pc++;
	Datum d = pop();
	if (!isinteger(d.val)) execerror("non integral index","");
	int num = (int)d.val;
	double *check = (double *)malloc(sizeof(double)*(num + 1));
	if (check == NULL) execerror("out of space","");
	sp->u.arrptr = check;
	(sp->u.arrptr)[0] = num;
	return 2;
}

int arrassign()
{
	symbol *sp = (symbol *)*pc++;
	int args = (int)*pc++;

	double *check = (double *)malloc(sizeof(double)*(args+1));
	if (check == NULL) execerror("out of space","");
	sp->u.arrptr = check;
	(sp->u.arrptr)[0] = args;
	for (int i = args; i > 0; i--)
	{
		Datum d;
		d = pop();
		(sp->u.arrptr)[i] = d.val;
	}
	return 2;
}

int arrpush()
{
	symbol *sp = (symbol *)*pc++;
	if(sp->type != ARRAY) execerror("not an array",sp->name);
	Datum d = pop();
	Datum in = pop();
	if (!isinteger(in.val)) execerror("non integral index","");
	int index =(int)in.val + 1;
	if (index < 1 || index > (sp->u.arrptr)[0]) execerror("illegal reference","");
	(sp->u.arrptr)[index] = d.val;
	push(d);
	return 2;
}

int arrpop()
{
	symbol *sp = (symbol *)*pc++;
	if(sp->type != ARRAY) execerror("not an array",sp->name);
	Datum d = pop();
	if(!isinteger(d.val)) execerror("non integral index","");
	int index = (int)d.val + 1;
	if (index < 1 || index > (sp->u.arrptr)[0]) execerror("illegal reference","");
	Datum d1;
	d1.val = (sp->u.arrptr)[index];
	push(d1);
	return 2;
}

int arrlen()
{
	symbol *sp = (symbol *)*pc++;
	Datum d;
	d.val = (sp->u.arrptr)[0];
	push(d);
	return 2;
}

int cnflush()
{
	int check = (int)(*pc++);
	if (check != fp->nargs) execerror("not enough arguments passed","");
}

char *checklen(int len)
{
	char *check = (char *)malloc(len);
	if (check == NULL) execerror("not enough space","");
	else return check;
}

int parassgn() {
    symbol *sp = (symbol *)(*pc++);
    // Get value from top of stack and pop it
    Datum d = pop(); 
    (fp->local)[fp->currstatus].u.val = d.val;
    
    // Allocate space including the null terminator
    int size = strlen(sp->name) + 1; 
    (fp->local)[fp->currstatus].name = checklen(size);
    strcpy((fp->local)[fp->currstatus].name, sp->name);
    
    (fp->local)[fp->currstatus].type = VAR;
    fp->currstatus++;
    return 2;
}
//custom functions can be added here
#include <math.h>
#include <stdlib.h>
#define PI 3.14159265358979323846
double Rand()
{
	return (double)rand()/(double)RAND_MAX;
}

double Atan(double p1)
{
	double p = atan(p1);
	return p*(180/PI);
}

double Atan2(double p1, double p2)
{
	double p = atan2(p1,p2);
	return p*(180/PI);
}
#include "hoc.h"
#include "hoc.tab.h"
#include <math.h>
#include <stdlib.h>

extern double Rand(), Atan(double p1), Atan2(double p1, double p2); 
extern double execerror(const char *s, const char *t);
extern void makebufs();

extern int sizes;
extern int sizep;

static struct 
{
	char *name;
	double cval;
} consts[] = 
{
	"PI",    3.14159265358979323846,
	"E",     2.71828182845904523536,
	"GAMMA", 0.57721566490153286060,
	"DEG",  57.29577951308232087680,
	"PHI",   1.61803398874989484820,
	0,0
};

static struct
{
	char *name;
	double (*func)();
} builtins[] = 
{
	"sin", 	 sin,
	"cos", 	 cos,
	"atan",  Atan,
	"ln",    log,
	"log",   log10,
	"exp",   exp,
	"sqrt",  sqrt,
	"int",   floor,
	"abs",   fabs,
	0,0
};

static struct
{
	char *name;
	double (*func)();
} builtin2s[] =
{
	"atan2", Atan2,
	0,0
};

static struct
{
	char *name;
	double (*func)();
} builtin0s[] =
{
	"rand", Rand,
	0,0
};

static struct 
{
	char *name;
	int kval;
} keywords[] = 
{
	"if",			IF,
	"else",		ELSE,
	"for", 		FOR,
	"while",	WHILE,
	"print",	PRINT,
	"break", BREAK,
	"continue", CONTINUE,
	"void",			PROC,
	"func", 		FUNC,
	"print",		PRINT,
	"read",			READ,
	"return", 	RETURN,
	"arr",			ARR,
	"len",		 ARRLEN,
	0,0
};

void echeck(double val)
{
	if (isnan(val)) execerror("arugments out of domain","");
	if (isinf(val)) execerror("function out of range","");
}
	

Datum dispatch(Datum p1, Datum p2, symbol *s)
{
	Datum ans;
	if (s->type == BLTIN0)
	{
		ans.val = (s->u.ptr)();
	}
	else if (s->type == BLTIN)
	{
		ans.val = (s->u.ptr)(p1.val);
	}
	else if (s->type == BLTIN2)
	{
		ans.val = (s->u.ptr)(p1.val,p2.val);
	}
	echeck(ans.val);
	return ans;
}

void init()
{
	makebufs();
	int i;
	symbol *s;
	install("_",VAR,0.0);
	for (i = 0; keywords[i].name; i++)
	{
		install(keywords[i].name, keywords[i].kval, 0.0);
	}
	for (i = 0; consts[i].name; i++)
	{
		install(consts[i].name,CNST,consts[i].cval);
	}
	for (i = 0; builtins[i].name; i++)
	{
		s = install(builtins[i].name, BLTIN, 0.0);
		s->u.ptr = builtins[i].func;
	}
	for (i = 0; builtin2s[i].name; i++)
	{
		s = install(builtin2s[i].name, BLTIN2, 0.0);
		s->u.ptr = builtin2s[i].func;
	}
	for (i = 0; builtin2s[i].name; i++)
	{
		s = install(builtin0s[i].name, BLTIN0, 0.0);
		s->u.ptr = builtin0s[i].func;
	}
}
